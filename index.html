<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excel Data Analyzer with AG Grid & Flask</title>

    <!-- AG Grid CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@31.0.0/styles/ag-grid.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ag-grid-community@31.0.0/styles/ag-theme-alpine.css">

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', 'Segoe UI', Tahoma, Verdana, sans-serif;
            padding: 20px;
            background: linear-gradient(135deg, #003D7A 0%, #003D7A 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 32px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .section {
            margin-bottom: 35px;
            padding: 20px;
            background: #ffffff;
            border-radius: 8px;
            border-left: 4px solid #003D7A;
        }

        .section-title {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #444;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-badge {
            background: #003D7A;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
        }

        .column-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .column-checkbox {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .column-checkbox:hover {
            border-color: #003D7A;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
        }

        .column-checkbox input {
            margin-right: 8px;
            cursor: pointer;
        }

        .column-checkbox input:checked + span {
            color: #003D7A;
            font-weight: 600;
        }

        /* Slicers Styling */
        .slicers-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .slicer {
            background: white;
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #e0e0e0;
        }

        .slicer-title {
            font-weight: 600;
            margin-bottom: 10px;
            color: #444;
            font-size: 14px;
        }

        .slicer-options {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            background: #ffffff;
        }

        .slicer-option {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .slicer-option:hover {
            background: #ffffff;
        }

        .slicer-option input {
            margin-right: 8px;
        }

        .slicer-option label {
            cursor: pointer;
            font-size: 13px;
            margin: 0;
            flex: 1;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            background: #003D7A;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button:hover {
            background: #003D7A;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #5a6268;
        }

        #myGrid {
            height: 500px;
            width: 100%;
            margin-bottom: 20px;
        }

        .chart-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        label {
            margin-bottom: 5px;
            font-weight: 600;
            color: #555;
            font-size: 13px;
        }

        select {
            padding: 10px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        select:focus {
            outline: none;
            border-color: #003D7A;
        }

        /* Scrollable Chart Container */
        .chart-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
            margin-bottom: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
            background: white;
        }

        .chart-container {
            min-width: 100%;
            position: relative;
        }

        #chartCanvas {
            display: block;
            max-height: 500px;
        }

        .info-box {
            background: linear-gradient(135deg, #003D7A 0%, #003D7A 100%);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            color: white;
            font-weight: 500;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        .checkbox-label input {
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Excel Data Analyzer with Flask + AG Grid</h1>
<!--        <p class="subtitle">Simple and powerful data visualization with column selection, multiple slicers, and dynamic charting</p> -->

        <!-- Step 1: Column Selection -->
        <div class="section">
            <div class="section-title">
                <span class="step-badge">1</span>
                Select Columns to Display
            </div>
            <div class="column-selector" id="columnSelector">
                {% for column in columns %}
                <label class="column-checkbox">
                    <input type="checkbox" value="{{ column }}" checked>
                    <span>{{ column }}</span>
                </label>
                {% endfor %}
            </div>
            <div class="button-group">
                <button onclick="loadData()">Load Selected Columns</button>
                <button class="secondary" onclick="selectAll()">Select All</button>
                <button class="secondary" onclick="deselectAll()">Deselect All</button>
            </div>
        </div>

        <!-- Step 1.5: Slicers for Advanced Filtering -->
        <div class="section">
            <div class="section-title">
                <span class="step-badge">1.5</span>
                Advanced Filters (Slicers)
            </div>
            <div class="info-box">
                Select specific values from each column to filter your data. Multiple selections within a slicer are combined with OR logic.
            </div>
            <div class="button-group">
                <button onclick="initializeSlicers()">Initialize Slicers</button>
                <button class="secondary" onclick="applySlicerFilters()">Apply Filters</button>
                <button class="secondary" onclick="clearAllSlicers()">Clear All Filters</button>
            </div>
            <div id="slicersContainer" class="slicers-container">
                <!-- Slicers will be dynamically generated here -->
            </div>
        </div>

        <!-- Step 1.6: Date-Based Slicer (Fixed Column) -->
        <div class="section">
            <div class="section-title">
                <span class="step-badge">1.6</span>
                Date-Based Slicer (Fixed Column)
            </div>
            <div class="info-box">
                Select a date column once and filter by date values. The column cannot be changed without resetting.
            </div>
            <div class="form-group" style="max-width: 300px; margin-bottom: 15px;">
                <label for="dateSlicerColumn">Select Date Column:</label>
                <select id="dateSlicerColumn" onchange="initializeDateSlicer()">
                    <option value="">-- Choose a date column --</option>
                </select>
            </div>
            <div class="button-group">
                <button class="secondary" onclick="applyDateSlicerFilter()">Apply Date Filter</button>
                <button class="secondary" onclick="clearDateSlicer()">Clear & Reset</button>
            </div>
            <div id="dateSlicerContainer" style="margin-top: 15px;">
                <!-- Date slicer will be dynamically generated here -->
            </div>
        </div>

        <!-- Step 2: Data Grid -->
        <div class="section">
            <div class="section-title">
                <span class="step-badge">2</span>
                View and Filter Data
            </div>
            <div id="myGrid" class="ag-theme-alpine"></div>
        </div>

        <!-- Step 3: Chart Creation -->
        <div class="section">
            <div class="section-title">
                <span class="step-badge">3</span>
                Create Dynamic Charts from Filtered Data
            </div>
            <div class="info-box">
                Charts automatically skip null and zero values. For large datasets, charts become scrollable horizontally to maintain bar width.
            </div>

            <div class="chart-controls">
                <div class="form-group">
                    <label for="chartType">Chart Type:</label>
                    <select id="chartType" onchange="handleChartTypeChange()">
                        <option value="bar">Bar Chart</option>
                        <option value="line">Line Chart</option>
                        <option value="pie">Pie Chart</option>
                        <option value="scatter">Scatter Plot</option>
                        <option value="doughnut">Doughnut Chart</option>
                        <option value="area">Area Chart</option>
                        <option value="radar">Radar Chart</option>
                        <option value="horizontalBar">Horizontal Bar</option>
                        <option value="combination">Combination Chart (Bar + Line)</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="xColumn">X-Axis Column:</label>
                    <select id="xColumn"></select>
                </div>

                <div class="form-group">
                    <label for="yColumn"><span id="yColumnLabel">Y-Axis Column:</span></label>
                    <select id="yColumn"></select>
                </div>

                <div class="form-group" id="y2ColumnsGroup" style="display: none;">
                    <label for="y2Columns">Y2-Axis Columns (Lines):</label>
                    <div id="y2ColumnsContainer" style="max-height: 150px; overflow-y: auto; border: 1px solid #e0e0e0; border-radius: 4px; padding: 8px; background: #fafafa;">
                        <!-- Y2 column checkboxes will be dynamically generated here -->
                    </div>
                </div>

                <div class="form-group">
                    <label for="aggregation">Aggregation Method:</label>
                    <select id="aggregation">
                        <option value="sum">Sum</option>
                        <option value="average">Average</option>
                        <option value="count">Count</option>
                        <option value="min">Minimum</option>
                        <option value="max">Maximum</option>
                    </select>
                </div>

                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="groupData" checked>
                        Group by X-Axis
                    </label>
                </div>

                <div class="form-group">
                    <label class="checkbox-label">
                        <input type="checkbox" id="skipNullZero" checked>
                        Skip Null & Zero Values
                    </label>
                </div>
            </div>

            <button onclick="createChart()" style="margin-bottom: 20px;">Generate Chart</button>

            <div class="chart-wrapper" id="chartWrapper">
                <div class="chart-container" id="chartContainer">
                    <canvas id="chartCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- AG Grid JS -->
    <script src="https://cdn.jsdelivr.net/npm/ag-grid-community@31.0.0/dist/ag-grid-community.min.js"></script>

    <script>
        let gridApi;
        let currentChart = null;
        let currentColumns = [];
        let slicersData = {};
        let dateSlicerColumn = null;
        let dateSlicerValues = [];
        let dateColumns = [];
        let millionColumns = [];  // Track columns with values >= 1 million

        // Initialize AG Grid
        const gridOptions = {
            defaultColDef: {
                sortable: true,
                filter: true,
                resizable: true,
                floatingFilter: true,
            },
            pagination: true,
            paginationPageSize: 20,
            rowSelection: 'multiple',
            onFilterChanged: updateChartColumnOptions
        };

        // Auto-detect and format columns with millions
        function autoMillionFormatter(params) {
            const value = params.value;

            if (value == null || isNaN(value)) {
                return value;
            }

            const numValue = parseFloat(value);

            // Format as millions with dollar sign
            const millions = (numValue / 1000000).toFixed(2);
            return `$${millions}M`;
        }

        // Check if column needs million formatting
        function needsMillionFormat(columnData) {
            // Check if any value in the column is >= 1,000,000
            return columnData.some(row => {
                const value = parseFloat(row);
                return !isNaN(value) && Math.abs(value) >= 1000000;
            });
        }

        // Format Y-axis values in millions for charts
        function chartAxisFormatter(value, index, ticks) {
            if (Math.abs(value) >= 1) {  // Already in millions
                return '$' + value.toFixed(1) + 'M';
            }
            return '$' + value.toLocaleString();
        }

        // Convert values to millions if column is in million format
        function convertChartValues(values, columnName) {
            if (millionColumns.includes(columnName)) {
                return values.map(v => {
                    const num = parseFloat(v);
                    return isNaN(num) ? v : num / 1000000;
                });
            }
            return values;
        }

        // Load data with selected columns
        async function loadData() {
            const checkboxes = document.querySelectorAll('#columnSelector input[type="checkbox"]:checked');
            const selectedColumns = Array.from(checkboxes).map(cb => cb.value);

            if (selectedColumns.length === 0) {
                alert('Please select at least one column');
                return;
            }

            try {
                const response = await fetch('/get_data', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({columns: selectedColumns})
                });

                const result = await response.json();
                currentColumns = result.columns;

                // Reset million columns tracking
                millionColumns = [];

                // Create column definitions with auto-million formatting
                const columnDefs = result.columns.map(col => {
                    const colDef = {
                        field: col,
                        headerName: col
                    };

                    // Get all values for this column
                    const columnValues = result.data.map(row => row[col]);

                    // Check if any value >= 1 million
                    if (needsMillionFormat(columnValues)) {
                        colDef.valueFormatter = autoMillionFormatter;
                        colDef.headerName = col + ' ($M)';
                        millionColumns.push(col);  // Track this column
                    }

                    return colDef;
                });

                // Initialize or update grid
                const gridDiv = document.querySelector('#myGrid');
                if (!gridApi) {
                    gridApi = agGrid.createGrid(gridDiv, gridOptions);
                }

                gridApi.setGridOption('columnDefs', columnDefs);
                gridApi.setGridOption('rowData', result.data);

                // Update chart column dropdowns
                updateChartColumnOptions();

            } catch (error) {
                console.error('Error loading data:', error);
                alert('Error loading data');
            }
        }

        // Initialize slicers with unique values from selected columns
        async function initializeSlicers() {
            const checkboxes = document.querySelectorAll('#columnSelector input[type="checkbox"]:checked');
            const selectedColumns = Array.from(checkboxes).map(cb => cb.value);

            if (selectedColumns.length === 0) {
                alert('Please select columns first');
                return;
            }

            const slicersContainer = document.getElementById('slicersContainer');
            slicersContainer.innerHTML = '<p style="padding: 20px; text-align: center;">Loading slicers...</p>';

            slicersData = {};

            // Create slicers for the first 5 columns (or all if less than 5)
            const columnsForSlicers = selectedColumns.slice(0, Math.max(5, selectedColumns.length));

            try {
                // Fetch unique values for each column
                for (const column of columnsForSlicers) {
                    const response = await fetch('/get_unique_values', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({column: column})
                    });

                    const result = await response.json();
                    slicersData[column] = result.uniqueValues;
                }

                // Render slicers
                renderSlicers();

            } catch (error) {
                console.error('Error initializing slicers:', error);
                alert('Error loading slicer data');
            }
        }

        // Render slicers UI
        function renderSlicers() {
            const slicersContainer = document.getElementById('slicersContainer');
            slicersContainer.innerHTML = '';

            Object.keys(slicersData).forEach(column => {
                const slicerDiv = document.createElement('div');
                slicerDiv.className = 'slicer';

                const title = document.createElement('div');
                title.className = 'slicer-title';
                title.textContent = column;
                slicerDiv.appendChild(title);

                const optionsDiv = document.createElement('div');
                optionsDiv.className = 'slicer-options';

                slicersData[column].forEach(value => {
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'slicer-option';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.value = value;
                    checkbox.id = `slicer-${column}-${value}`;
                    checkbox.dataset.column = column;

                    const label = document.createElement('label');
                    label.htmlFor = checkbox.id;
                    label.textContent = value;

                    optionDiv.appendChild(checkbox);
                    optionDiv.appendChild(label);
                    optionsDiv.appendChild(optionDiv);
                });

                slicerDiv.appendChild(optionsDiv);
                slicersContainer.appendChild(slicerDiv);
            });
        }

        // Apply slicer filters to AG Grid
        function applySlicerFilters() {
            if (!gridApi) {
                alert('Please load data first');
                return;
            }

            // Get all checked slicer values grouped by column
            const filtersByColumn = {};

            document.querySelectorAll('.slicer-option input:checked').forEach(checkbox => {
                const column = checkbox.dataset.column;
                const value = checkbox.value;

                if (!filtersByColumn[column]) {
                    filtersByColumn[column] = [];
                }
                filtersByColumn[column].push(value);
            });

            // Apply filters to AG Grid
            Object.keys(slicersData).forEach(column => {
                const filterInstance = gridApi.getColumnFilterInstance(column);

                if (filtersByColumn[column] && filtersByColumn[column].length > 0) {
                    // Set filter to include only selected values
                    filterInstance.setModel({
                        filterType: 'set',
                        values: filtersByColumn[column]
                    });
                } else {
                    // Clear filter for this column
                    filterInstance.setModel(null);
                }
            });

            gridApi.onFilterChanged();
        }

        // Clear all slicer filters
        function clearAllSlicers() {
            document.querySelectorAll('.slicer-option input').forEach(checkbox => {
                checkbox.checked = false;
            });

            if (gridApi) {
                gridApi.setFilterModel(null);
            }
        }

        // Update chart column dropdowns
        async function updateChartColumnOptions() {
            const xSelect = document.getElementById('xColumn');
            const ySelect = document.getElementById('yColumn');
            const dateSlicerSelect = document.getElementById('dateSlicerColumn');
            const y2Container = document.getElementById('y2ColumnsContainer');

            xSelect.innerHTML = '';
            ySelect.innerHTML = '';
            dateSlicerSelect.innerHTML = '<option value="">-- Choose a date column --</option>';
            y2Container.innerHTML = '';

            currentColumns.forEach(col => {
                xSelect.add(new Option(col, col));
                ySelect.add(new Option(col, col));

                // Add checkboxes for Y2 columns (for combination chart)
                const checkboxDiv = document.createElement('div');
                checkboxDiv.style.padding = '4px';
                checkboxDiv.innerHTML = `
                    <label style="cursor: pointer; display: flex; align-items: center; gap: 8px;">
                        <input type="checkbox" class="y2-column-checkbox" value="${col}">
                        <span>${col}</span>
                    </label>
                `;
                y2Container.appendChild(checkboxDiv);
            });

            // Fetch and populate date columns
            try {
                const response = await fetch('/get_date_columns');
                const result = await response.json();
                dateColumns = result.dateColumns;

                dateColumns.forEach(col => {
                    dateSlicerSelect.add(new Option(col, col));
                });
            } catch (error) {
                console.error('Error fetching date columns:', error);
            }
        }

        // Handle chart type changes
        function handleChartTypeChange() {
            const chartType = document.getElementById('chartType').value;
            const y2ColumnsGroup = document.getElementById('y2ColumnsGroup');
            const yColumnLabel = document.getElementById('yColumnLabel');

            // Show Y2 columns selector for combination chart
            if (chartType === 'combination') {
                y2ColumnsGroup.style.display = 'block';
                yColumnLabel.textContent = 'Y1-Axis Column (Bars):';
            } else {
                y2ColumnsGroup.style.display = 'none';
                yColumnLabel.textContent = 'Y-Axis Column:';
            }
        }

        // Initialize date-based slicer with fixed column
        async function initializeDateSlicer() {
            const selectedColumn = document.getElementById('dateSlicerColumn').value;

            if (!selectedColumn) {
                return;
            }

            // Lock the column selection
            dateSlicerColumn = selectedColumn;
            document.getElementById('dateSlicerColumn').disabled = true;

            const container = document.getElementById('dateSlicerContainer');
            container.innerHTML = '<p style="padding: 20px; text-align: center;">Loading date values...</p>';

            try {
                const response = await fetch('/get_unique_values', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({column: selectedColumn})
                });

                const result = await response.json();
                dateSlicerValues = result.uniqueValues;

                // Render date slicer
                renderDateSlicer();

            } catch (error) {
                console.error('Error initializing date slicer:', error);
                alert('Error loading date slicer values');
            }
        }

        // Render date-based slicer UI
        function renderDateSlicer() {
            const container = document.getElementById('dateSlicerContainer');
            container.innerHTML = '';

            const slicerDiv = document.createElement('div');
            slicerDiv.className = 'slicer';
            slicerDiv.style.maxWidth = '600px';

            const title = document.createElement('div');
            title.className = 'slicer-title';
            title.textContent = `${dateSlicerColumn} (Fixed Date Column)`;
            title.style.color = '#003D7A';
            title.style.fontWeight = 'bold';
            slicerDiv.appendChild(title);

            const optionsDiv = document.createElement('div');
            optionsDiv.className = 'slicer-options';
            optionsDiv.style.maxHeight = '300px';

            dateSlicerValues.forEach(value => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'slicer-option';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = value;
                checkbox.id = `date-slicer-${value}`;
                checkbox.className = 'date-slicer-checkbox';

                const label = document.createElement('label');
                label.htmlFor = checkbox.id;
                label.textContent = value;

                optionDiv.appendChild(checkbox);
                optionDiv.appendChild(label);
                optionsDiv.appendChild(optionDiv);
            });

            slicerDiv.appendChild(optionsDiv);
            container.appendChild(slicerDiv);
        }

        // Apply date slicer filter
        function applyDateSlicerFilter() {
            if (!gridApi || !dateSlicerColumn) {
                alert('Please initialize the date slicer first');
                return;
            }

            // Get checked values
            const checkedValues = [];
            document.querySelectorAll('.date-slicer-checkbox:checked').forEach(checkbox => {
                checkedValues.push(checkbox.value);
            });

            const filterInstance = gridApi.getColumnFilterInstance(dateSlicerColumn);

            if (checkedValues.length > 0) {
                filterInstance.setModel({
                    filterType: 'set',
                    values: checkedValues
                });
            } else {
                filterInstance.setModel(null);
            }

            gridApi.onFilterChanged();
        }

        // Clear date slicer and reset
        function clearDateSlicer() {
            document.querySelectorAll('.date-slicer-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });

            if (gridApi && dateSlicerColumn) {
                const filterInstance = gridApi.getColumnFilterInstance(dateSlicerColumn);
                filterInstance.setModel(null);
                gridApi.onFilterChanged();
            }

            // Reset and unlock column selection
            dateSlicerColumn = null;
            dateSlicerValues = [];
            document.getElementById('dateSlicerColumn').value = '';
            document.getElementById('dateSlicerColumn').disabled = false;
            document.getElementById('dateSlicerContainer').innerHTML = '';
        }

        // Create chart from filtered data
        async function createChart() {
            const chartType = document.getElementById('chartType').value;
            const xColumn = document.getElementById('xColumn').value;
            const yColumn = document.getElementById('yColumn').value;
            const aggregation = document.getElementById('aggregation').value;
            const shouldGroup = document.getElementById('groupData').checked;
            const skipNullZero = document.getElementById('skipNullZero').checked;

            if (!xColumn || !yColumn) {
                alert('Please select X and Y columns');
                return;
            }

            // Get filtered data from AG Grid
            const filteredData = [];
            gridApi.forEachNodeAfterFilter(node => {
                filteredData.push(node.data);
            });

            if (filteredData.length === 0) {
                alert('No data available after filtering');
                return;
            }

            // Destroy existing chart
            if (currentChart) {
                currentChart.destroy();
            }

            const chartContainer = document.getElementById('chartContainer');
            const canvas = document.getElementById('chartCanvas');
            const ctx = canvas.getContext('2d');

            // Handle combination chart separately
            if (chartType === 'combination') {
                const y2Checkboxes = document.querySelectorAll('.y2-column-checkbox:checked');
                const y2Columns = Array.from(y2Checkboxes).map(cb => cb.value);

                if (y2Columns.length === 0) {
                    alert('Please select at least one Y2 column for the line chart');
                    return;
                }

                createCombinationChart(ctx, filteredData, xColumn, yColumn, y2Columns, aggregation, shouldGroup, skipNullZero);
                return;
            }

            // Process data for other chart types
            let xValues, yValues;

            if (shouldGroup) {
                const aggregated = aggregateData(filteredData, xColumn, yColumn, aggregation, skipNullZero);
                xValues = aggregated.x;
                yValues = convertChartValues(aggregated.y, yColumn);  // Convert to millions if needed
            } else {
                const processed = processData(filteredData, xColumn, yColumn, skipNullZero);
                xValues = processed.x;
                yValues = convertChartValues(processed.y, yColumn);  // Convert to millions if needed
            }

            // Calculate dynamic width for scrollable chart
            const minBarWidth = 40; // minimum width per bar in pixels
            const calculatedWidth = Math.max(800, xValues.length * minBarWidth);

            // Set canvas width for horizontal scrolling
            if (chartType === 'bar' || chartType === 'horizontalBar' || chartType === 'combination') {
                chartContainer.style.width = calculatedWidth + 'px';
                canvas.width = calculatedWidth;
            } else {
                chartContainer.style.width = '100%';
                canvas.width = 800;
            }

            // Create chart
            createBasicChart(ctx, chartType, xValues, yValues, xColumn, yColumn);
        }

        // Process data without grouping
        function processData(data, xCol, yCol, skipNullZero) {
            const xValues = [];
            const yValues = [];

            data.forEach(row => {
                const xVal = row[xCol];
                const yVal = parseFloat(row[yCol]);

                // Skip null/zero values if option is enabled
                if (skipNullZero && (yVal === null || yVal === undefined || yVal === 0 || isNaN(yVal))) {
                    return;
                }

                xValues.push(xVal);
                yValues.push(yVal);
            });

            return { x: xValues, y: yValues };
        }

        // Aggregate data by X column
        function aggregateData(data, xCol, yCol, aggMethod, skipNullZero) {
            const grouped = {};

            // Group data by X column
            data.forEach(row => {
                const key = row[xCol];
                const yVal = parseFloat(row[yCol]);

                // Skip null/zero values if option is enabled (before aggregation)
                if (skipNullZero && (yVal === null || yVal === undefined || yVal === 0 || isNaN(yVal))) {
                    return;
                }

                if (!grouped[key]) {
                    grouped[key] = [];
                }

                if (!isNaN(yVal)) {
                    grouped[key].push(yVal);
                }
            });

            // Apply aggregation function
            const result = { x: [], y: [] };

            Object.keys(grouped).forEach(key => {
                // Skip if no valid values after filtering
                if (grouped[key].length === 0) {
                    return;
                }

                const aggregatedValue = applyAggregation(grouped[key], aggMethod);

                // Skip if aggregated value is zero (when skipNullZero is enabled)
                if (skipNullZero && aggregatedValue === 0) {
                    return;
                }

                result.x.push(key);
                result.y.push(aggregatedValue);
            });

            return result;
        }

        // Apply aggregation method to array
        function applyAggregation(arr, method) {
            if (arr.length === 0) return 0;

            switch(method) {
                case 'sum':
                    return arr.reduce((a, b) => a + b, 0);
                case 'average':
                    return arr.reduce((a, b) => a + b, 0) / arr.length;
                case 'count':
                    return arr.length;
                case 'min':
                    return Math.min(...arr);
                case 'max':
                    return Math.max(...arr);
                default:
                    return arr.reduce((a, b) => a + b, 0);
            }
        }

        // Create combination chart (Bar + Line)
        function createCombinationChart(ctx, data, xColumn, y1Column, y2Columns, aggMethod, shouldGroup, skipNullZero) {
            // Process Y1 data (bars)
            let xValues, y1Values;
            if (shouldGroup) {
                const aggregated = aggregateData(data, xColumn, y1Column, aggMethod, skipNullZero);
                xValues = aggregated.x;
                y1Values = convertChartValues(aggregated.y, y1Column);  // Convert to millions if needed
            } else {
                const processed = processData(data, xColumn, y1Column, skipNullZero);
                xValues = processed.x;
                y1Values = convertChartValues(processed.y, y1Column);  // Convert to millions if needed
            }

            // Process Y2 data (lines)
            const datasets = [{
                label: y1Column + ' (Bar)',
                data: y1Values,
                backgroundColor: 'rgba(54, 162, 235, 0.6)',
                borderColor: 'rgba(54, 162, 235, 1)',
                borderWidth: 2,
                type: 'bar',
                yAxisID: 'y1'
            }];

            const lineColors = [
                'rgba(255, 99, 132, 1)',
                'rgba(75, 192, 192, 1)',
                'rgba(153, 102, 255, 1)',
                'rgba(255, 159, 64, 1)',
                'rgba(255, 206, 86, 1)',
                'rgba(201, 203, 207, 1)'
            ];

            y2Columns.forEach((y2Col, index) => {
                let y2Values;
                if (shouldGroup) {
                    const aggregated = aggregateData(data, xColumn, y2Col, aggMethod, skipNullZero);
                    y2Values = convertChartValues(aggregated.y, y2Col);  // Convert to millions if needed
                } else {
                    const processed = processData(data, xColumn, y2Col, skipNullZero);
                    y2Values = convertChartValues(processed.y, y2Col);  // Convert to millions if needed
                }

                datasets.push({
                    label: y2Col + ' (Line)',
                    data: y2Values,
                    borderColor: lineColors[index % lineColors.length],
                    backgroundColor: lineColors[index % lineColors.length].replace('1)', '0.1)'),
                    borderWidth: 3,
                    type: 'line',
                    yAxisID: 'y2',
                    tension: 0.4,
                    fill: false
                });
            });

            currentChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: xValues,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `Combination Chart: ${y1Column} (Bars) & ${y2Columns.join(', ')} (Lines)`,
                            font: { size: 18, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: 'x',
                            },
                            pan: {
                                enabled: true,
                                mode: 'x',
                            }
                        }
                    },
                    scales: {
                        y1: {
                            type: 'linear',
                            position: 'left',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: millionColumns.includes(y1Column) ? y1Column + ' ($M - Bars)' : y1Column + ' (Bars)'
                            },
                            ticks: millionColumns.includes(y1Column) ? {
                                callback: chartAxisFormatter
                            } : {}
                        },
                        y2: {
                            type: 'linear',
                            position: 'right',
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: y2Columns.some(col => millionColumns.includes(col)) ? 'Lines ($M)' : 'Lines'
                            },
                            ticks: {
                                callback: function(value, index, ticks) {
                                    // Check if any Y2 column is in millions
                                    const anyY2InMillions = y2Columns.some(col => millionColumns.includes(col));
                                    if (anyY2InMillions) {
                                        return chartAxisFormatter(value, index, ticks);
                                    }
                                    return value;
                                }
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: xColumn
                            }
                        }
                    }
                }
            });
        }

        // Create basic chart
        function createBasicChart(ctx, type, xValues, yValues, xColumn, yColumn) {
            const isHorizontal = type === 'horizontalBar';
            const actualType = isHorizontal ? 'bar' : type;

            // Special handling for area chart (line chart with fill)
            const isFilled = type === 'area';
            const chartType = isFilled ? 'line' : actualType;

            currentChart = new Chart(ctx, {
                type: chartType,
                data: {
                    labels: xValues,
                    datasets: [{
                        label: yColumn,
                        data: yValues,
                        backgroundColor: getColors(xValues.length, isFilled ? 0.3 : 0.6),
                        borderColor: getColors(xValues.length, 1),
                        borderWidth: 2,
                        tension: 0.4,
                        fill: isFilled
                    }]
                },
                options: {
                    indexAxis: isHorizontal ? 'y' : 'x',
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        title: {
                            display: true,
                            text: `${yColumn} by ${xColumn}`,
                            font: { size: 18, weight: 'bold' }
                        },
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        zoom: {
                            zoom: {
                                wheel: { enabled: true },
                                pinch: { enabled: true },
                                mode: type === 'radar' ? 'xy' : 'x',
                            },
                            pan: {
                                enabled: true,
                                mode: type === 'radar' ? 'xy' : 'x',
                            }
                        }
                    },
                    scales: type !== 'pie' && type !== 'doughnut' && type !== 'radar' ? {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: isHorizontal ? xColumn : (millionColumns.includes(yColumn) ? yColumn + ' ($M)' : yColumn)
                            },
                            ticks: millionColumns.includes(yColumn) && !isHorizontal ? {
                                callback: chartAxisFormatter
                            } : {}
                        },
                        x: {
                            title: {
                                display: true,
                                text: isHorizontal ? (millionColumns.includes(yColumn) ? yColumn + ' ($M)' : yColumn) : xColumn
                            },
                            ticks: millionColumns.includes(yColumn) && isHorizontal ? {
                                callback: chartAxisFormatter
                            } : {}
                        }
                    } : {}
                }
            });
        }

        // Helper: Generate color palette
        function getColors(count, alpha) {
            const baseColors = [
                [102, 126, 234], [118, 75, 162], [255, 99, 132],
                [54, 162, 235], [255, 206, 86], [75, 192, 192],
                [153, 102, 255], [255, 159, 64], [199, 199, 199],
                [83, 102, 255], [255, 99, 255], [99, 255, 132]
            ];

            return Array(count).fill(0).map((_, i) => {
                const color = baseColors[i % baseColors.length];
                return `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${alpha})`;
            });
        }

        // Column selection helpers
        function selectAll() {
            document.querySelectorAll('#columnSelector input[type="checkbox"]').forEach(cb => {
                cb.checked = true;
            });
        }

        function deselectAll() {
            document.querySelectorAll('#columnSelector input[type="checkbox"]').forEach(cb => {
                cb.checked = false;
            });
        }

        // Load data on page load
        window.addEventListener('DOMContentLoaded', () => {
            loadData();
        });
    </script>
</body>
</html>